# RabbitMQ



## publisher-confirm-type

用于确定消息是否已经被接收和处理。

1. `SIMPLE`： 在 `SIMPLE` 模式下，发布者发送消息到消息代理（如 RabbitMQ），代理将消息发送到队列或交换机，并返回一个简单的确认给发布者。这个确认仅表示消息已被代理接收，但并不意味着消息已经成功传递到队列或被消费者处理。这种模式下，消息可能会在代理崩溃前丢失，因为确认只表示代理已经接收到消息。
2. `CORRELATED`： 在 `CORRELATED` 模式下，消息代理会返回与特定消息相关的确认。这意味着每条消息都有一个关联的确认，发布者可以通过消息的 ID 或标识来匹配确认。这种模式可以更精确地了解哪些消息已经成功传递到队列或被消费者处理。
3. `NONE`： `NONE` 模式与确认无关，发布者发送消息到代理后，不会等待任何确认。这可能会导致消息的丢失或无法确定消息是否已经被成功处理。

这些模式可以根据你的应用程序需求来选择。如果你需要更高的消息可靠性和确认机制，可以选择 `CORRELATED` 模式。如果你对消息丢失有一定的容忍度，而且希望减少消息发送的延迟，可以选择 `SIMPLE` 或 `NONE` 模式。

## 消息监听容器


`simple` 和 `direct` 是两种不同的消息监听容器类型，用于处理从 RabbitMQ 接收的消息。它们之间的区别主要体现在消息处理的方式和用途。

1. `simple` 消息监听容器： `simple` 消息监听容器是一种简单的消息监听方式，适用于单一队列上的消息消费。它适合处理只需要简单消费消息的场景。在 `simple` 容器中，每个消息都会被一个独立的线程处理，这意味着不同消息之间的处理是并行的，但每个消息都在单独的线程中进行。这可以提高消息处理的并发性能。
2. `direct` 消息监听容器： `direct` 消息监听容器是一种更为灵活的消息监听方式，适用于多个队列和多个消费者之间的消息分发。它可以设置多个队列和消费者，每个队列可以分配给一个或多个消费者。这样，你可以实现更复杂的消息路由和分发逻辑，以满足不同的业务需求。在 `direct` 容器中，消息的分发是根据交换机和绑定规则来进行的。

总之，`simple` 消息监听容器适用于简单的消息消费场景，其中每个消息都被单独处理；而 `direct` 消息监听容器适用于需要更灵活的消息分发和路由逻辑的场景，可以在多个队列和消费者之间进行消息的合理分配。
